<!doctype html>
<html>
<head>
    <script src="/engine/build/output/playcanvas-latest.js"></script>
    <script src="http://code.playcanvas.com/ammo.3c2cc63.js"></script>
    <style>
        html, body {
            margin: 0px;
            padding: 0px;
        }
    </style>
</head>

<body>
    <!-- The canvas element -->
    <canvas id="application-canvas"></canvas>

    <!-- The script -->
    <script>
        var canvas = document.getElementById("application-canvas");

        // Create the application and start the update loop
        var application = new pc.fw.Application(canvas);
        application.start();

        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size
        application.setCanvasFillMode(pc.fw.FillMode.FILL_WINDOW);
        application.setCanvasResolution(pc.fw.ResolutionMode.AUTO);

        application.context.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);

        // Set the gravity for our rigid bodies
        application.context.systems.rigidbody.setGravity(0, -9.8, 0);

        // Create our floor
        var floor = new pc.fw.Entity();

        // add a 'box' model
        application.context.systems.model.addComponent(floor, {
            type: "box",
        });

        // scale it
        floor.setLocalScale(10, 1, 10);

        // add a collision component
        application.context.systems.collision.addComponent(floor, {
            type: "box",
            halfExtents: new pc.Vec3(5, 0.5, 5)
        });

        // add a rigidbody component so that other objects collide with it
        application.context.systems.rigidbody.addComponent(floor, {
            type: "static",
            restitution: 0.5
        });


        // make our scene prettier by adding a directional light
        var light = new pc.fw.Entity();
        application.context.systems.light.addComponent(light, {
            type: "directional",
            color: new pc.Color(0.7, 0.7, 0.7),
            castShadows: true,
            shadowResolution: 2048
        });

        // set the direction for our light
        light.setLocalEulerAngles(45, 30, 0);

        // Create an Entity with a camera component
        var camera = new pc.fw.Entity();
        application.context.systems.camera.addComponent(camera, {
            clearColor: new pc.Color(0.8, 0.8, 0.8),
            farClip: 50
        });

        // Add the new Entities to the hierarchy
        application.context.root.addChild(floor);
        application.context.root.addChild(light);
        application.context.root.addChild(camera);

        // Move the camera a little further away
        camera.translate(0, 10, 15);
        camera.lookAt(0, 0, 0);

        // Create a template for a falling box
        // It will have a model component of type 'box'...
        var boxTemplate = new pc.fw.Entity();
        application.context.systems.model.addComponent(boxTemplate, {
            type: "box",
            castShadows: true
        });

        // ... a collision component of type 'box'...
        application.context.systems.collision.addComponent(boxTemplate, {
            type: "box",
            halfExtents: new pc.Vec3(0.5, 0.5, 0.5)
        });

        // ... and a rigidbody component of type 'dynamic' so that it is simulated
        // by the physics engine
        application.context.systems.rigidbody.addComponent(boxTemplate, {
            type: "dynamic",
            mass: 50,
            restitution: 0.5
        });

        // initialize variables for our update method
        var timer = 0;
        var count = 40;

        // Set an update function on the application's update event
        application.on("update", function (dt) {
            // create a falling box every 0.2 seconds
            if (count > 0) {
                timer -= dt;
                if (timer <= 0) {
                    count--;
                    timer = 0.2;

                    // Clone the box template and position it above the floor
                    var clone = boxTemplate.clone();
                    application.context.root.addChild(clone);
                    clone.setLocalPosition(pc.math.random(-1,1), 10, pc.math.random(-1,1));

                    // when we manually change the position of an Entity with a dynamic rigidbody
                    // we need to call syncEntityToBody() so that the rigidbody will get the position
                    // and rotation of the Entity.
                    clone.rigidbody.syncEntityToBody();

                }
            }

        });
    </script>
</body>
</html>
