pc.extend(pc, function () {
    /**
     * @component
     * @name pc.LightComponent
     * @class The Light Component enables the Entity to light the scene. There are three types
     * of light: directional, point and spot. Directional lights are global in that they are
     * considered to be infinitely far away and light the entire scene. Point and spot lights
     * are local in that they have a position and a range. A spot light is a specialization of
     * a point light where light is emitted in a cone rather than in all directions. Lights
     * also have the ability to cast shadows to add realism to your scenes.
     * @description Creates a new Light Component.
     * @param {pc.LightComponentSystem} system The ComponentSystem that created this Component.
     * @param {pc.Entity} entity The Entity that this Component is attached to.
     * @example
     * // Add a pc.LightComponent to an entity
     * var entity = new pc.Entity();
     * entity.addComponent('light', {
     *     type: "point",
     *     color: new pc.Color(1, 0, 0),
     *     range: 10
     * });
     * @example
     * // Get the pc.LightComponent on an entity
     * var lightComponent = entity.light;
     * @example
     * // Update a property on a light component
     * entity.light.range = 20;
     * @property {String} type The type of light. Can be:
     * <ul>
     *     <li>"directional": A light that is infinitely far away and lights the entire scene from one direction.</li>
     *     <li>"point": A light that illuminates in all directions from a point.</li>
     *     <li>"spot": A light that illuminates in all directions from a point and is bounded by a cone.</li>
     * </ul>
     * Defaults to "directional".
     * @property {pc.Color} color The Color of the light. The alpha component of the color is
     * ignored. Defaults to white (1, 1, 1).
     * @property {Number} intensity The brightness of the light. Defaults to 1.
     * @property {Boolean} castShadows If enabled the light will cast shadows. Defaults to false.
     * @property {Number} shadowDistance The distance from the viewpoint beyond which shadows
     * are no longer rendered. Affects directional lights only. Defaults to 40.
     * @property {Number} shadowResolution The size of the texture used for the shadow map.
     * Valid sizes are 64, 128, 256, 512, 1024, 2048. Defaults to 1024.
     * @property {Number} shadowBias The depth bias for tuning the appearance of the shadow
     * mapping generated by this light. Defaults to 0.05.
     * @property {Number} normalOffsetBias Normal offset depth bias. Defaults to 0.
     * @property {Number} range The range of the light. Affects point and spot lights only.
     * Defaults to 10.
     * @property {Number} innerConeAngle The angle at which the spotlight cone starts
     * to fade off. The angle is specified in degrees. Affects spot lights only. Defaults
     * to 40.
     * @property {Number} outerConeAngle The angle at which the spotlight cone has faded
     * to nothing. The angle is specified in degrees. Affects spot lights only. Defaults
     * to 45.
     * @property {Number} falloffMode Controls the rate at which a light attentuates from
     * its position. Can be:
     * <ul>
     * <li>{@link pc.LIGHTFALLOFF_LINEAR}: Linear.</li>
     * <li>{@link pc.LIGHTFALLOFF_INVERSESQUARED}: Inverse squared.</li>
     * </ul>
     * Affects point and spot lights only. Defaults to pc.LIGHTFALLOFF_LINEAR.
     * @property {Number} mask Defines a mask to determine which {@link pc.MeshInstance}s are
     * lit by this light. Defaults to 1.
     * @property {Boolean} affectDynamic If enabled the light will affect non-lightmapped objects
     * @property {Boolean} affectLightmapped If enabled the light will affect lightmapped objects
     * @property {Boolean} bake If enabled the light will be rendered into lightmaps
     * @property {Number} shadowUpdateMode Tells the renderer how often shadows must be updated for this light. Options:
     * <ul>
     * <li>{@link pc.SHADOWUPDATE_NONE}: Don't render shadows.</li>
     * <li>{@link pc.SHADOWUPDATE_THISFRAME}: Render shadows only once (then automatically switches to pc.SHADOWUPDATE_NONE).</li>
     * <li>{@link pc.SHADOWUPDATE_REALTIME}: Render shadows every frame (default).</li>
     * </ul>
     * @property {Number} shadowType Type of shadows being rendered by this light. Options:
     * <ul>
     * <li>{@link pc.SHADOW_DEPTH}: Render packed depth, can be used for hard or PCF sampling.</li>
     * <li>{@link pc.SHADOW_VSM8}: Render packed variance shadow map. All shadow receivers must also cast shadows for this mode to work correctly.</li>
     * <li>{@link pc.SHADOW_VSM16}: Render 16-bit exponential variance shadow map. Requires OES_texture_half_float extension. Falls back to pc.SHADOW_VSM8, if not supported.</li>
     * <li>{@link pc.SHADOW_VSM32}: Render 32-bit exponential variance shadow map. Requires OES_texture_float extension. Falls back to pc.SHADOW_VSM16, if not supported.</li>
     * </ul>
     * @property {Number} vsmBlurMode Blurring mode for variance shadow maps:
     * <ul>
     * <li>{@link pc.BLUR_BOX}: Box filter.</li>
     * <li>{@link pc.BLUR_GAUSSIAN}: Gaussian filter. May look smoother than box, but requires more samples.</li>
     * </ul>
     * @property {Number} vsmBlurSize Number of samples used for blurring a variance shadow map. Only uneven numbers work, even are incremented. Minimum value is 1, maximum is 25.
     * @property {pc.Texture} cookie Projection texture. Must be 2D for spot and cubemap for point (ignored if incorrect type is used).
     * @property {Number} cookieIntensity Projection texture intensity (default is 1).
     * @property {Boolean} cookieFalloff Toggle normal spotlight falloff when projection texture is used. When set to false, spotlight will work like a pure texture projector (only fading with distance). Default is false.
     * @property {String} cookieChannel  Color channels of the projection texture to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination.
     * @extends pc.Component
     */

    var _props = [];
    var _propsDefault = [];
    function _defineProperty(c, d, s, name, defaultValue, setFunc) {
        _props.push(name);
        _propsDefault.push(defaultValue);

        Object.defineProperty(c, name, {
            get: function () {
                return this.data[name];
            },
            set: function (value) {
                var data = this.data;
                var oldValue = data[name];
                data[name] = value;
                if (setFunc) setFunc(this, value, oldValue)
            },
            configurable: true
        });
    }

    var lightTypes = {
        'directional': pc.LIGHTTYPE_DIRECTIONAL,
        'point': pc.LIGHTTYPE_POINT,
        'spot': pc.LIGHTTYPE_SPOT
    };

    var LightComponent = function LightComponent(system, entity) {
    };
    LightComponent = pc.inherits(LightComponent, pc.Component);

    var LightComponentData = function () {
        for(var i=0; i<_props.length; i++) {
            this[_props[i]] = _propsDefault[i];
        }
    };
    LightComponentData = pc.inherits(LightComponentData, pc.ComponentData);

    var LightComponentSystem = function (app) {
        this.id = 'light';
        this.description = "Enables the Entity to emit light.";
        app.systems.add(this.id, this);

        this.ComponentType = pc.LightComponent;
        this.DataType = pc.LightComponentData;

        this.on('remove', this.onRemove, this);
    };
    LightComponentSystem = pc.inherits(LightComponentSystem, pc.ComponentSystem);


    var _defineProps = function (c, d, s) {
        _defineProperty(c, d, s, "enabled", true, function(obj, newValue, oldValue) {
            obj.onSetEnabled(null, oldValue, newValue);
        });
        _defineProperty(c, d, s, "light", null);
        _defineProperty(c, d, s, "type", 'directional', function(obj, newValue, oldValue) {
            if (oldValue === newValue)
                return;
            obj.system.changeType(obj, oldValue, newValue);
            // refresh light properties because changing the type does not reset the
            // light properties
            obj.refreshProperties();
        });
        _defineProperty(c, d, s, "color", new pc.Color(1, 1, 1), function(obj, newValue, oldValue) {
            obj.light.setColor(newValue);
        });
        _defineProperty(c, d, s, "intensity", 1, function(obj, newValue, oldValue) {
            obj.light.setIntensity(newValue);
        });
        _defineProperty(c, d, s, "castShadows", false, function(obj, newValue, oldValue) {
            obj.light.setCastShadows(newValue);
        });
        _defineProperty(c, d, s, "shadowDistance", 40, function(obj, newValue, oldValue) {
            obj.light.setShadowDistance(newValue);
        });
        _defineProperty(c, d, s, "shadowResolution", 1024, function(obj, newValue, oldValue) {
            obj.light.setShadowResolution(newValue);
        });
        _defineProperty(c, d, s, "shadowBias", 0.05, function(obj, newValue, oldValue) {
            obj.light.setShadowBias(-0.01 * newValue);
        });
        _defineProperty(c, d, s, "normalOffsetBias", 0, function(obj, newValue, oldValue) {
            obj.light.setNormalOffsetBias(newValue);
        });
        _defineProperty(c, d, s, "range", 10, function(obj, newValue, oldValue) {
            obj.light.setAttenuationEnd(newValue);
        });
        _defineProperty(c, d, s, "innerConeAngle", 40, function(obj, newValue, oldValue) {
            obj.light.setInnerConeAngle(newValue);
        });
        _defineProperty(c, d, s, "outerConeAngle", 45, function(obj, newValue, oldValue) {
            obj.light.setOuterConeAngle(newValue);
        });
        _defineProperty(c, d, s, "falloffMode", pc.LIGHTFALLOFF_LINEAR, function(obj, newValue, oldValue) {
            obj.light.setFalloffMode(newValue);
        });
        _defineProperty(c, d, s, "shadowType", pc.SHADOW_DEPTH, function(obj, newValue, oldValue) {
            obj.light.setShadowType(newValue);
        });
        _defineProperty(c, d, s, "vsmBlurSize", 11, function(obj, newValue, oldValue) {
            obj.light.setVsmBlurSize(newValue);
        });
        _defineProperty(c, d, s, "vsmBlurMode", pc.BLUR_GAUSSIAN, function(obj, newValue, oldValue) {
            obj.light.setVsmBlurMode(newValue);
        });
        _defineProperty(c, d, s, "vsmBias", 0.01 * 0.25, function(obj, newValue, oldValue) {
            obj.light.setVsmBias(newValue);
        });
        _defineProperty(c, d, s, "cookie", null, function(obj, newValue, oldValue) {
            obj.light.setCookie(newValue);
        });
        _defineProperty(c, d, s, "cookieIntensity", 1, function(obj, newValue, oldValue) {
            obj.light.setCookieIntensity(newValue);
        });
        _defineProperty(c, d, s, "cookieFalloff", false, function(obj, newValue, oldValue) {
            obj.light.setCookieFalloff(newValue);
        });
        _defineProperty(c, d, s, "cookieChannel", "rgb", function(obj, newValue, oldValue) {
            obj.light.setCookieChannel(newValue);
        });
        _defineProperty(c, d, s, "shadowUpdateMode", pc.SHADOWUPDATE_REALTIME, function(obj, newValue, oldValue) {
            obj.light.shadowUpdateMode = newValue;
        });
        _defineProperty(c, d, s, "mask", 1, function(obj, newValue, oldValue) {
            obj.light.setMask(newValue);
        });
        _defineProperty(c, d, s, "affectDynamic", true, function(obj, newValue, oldValue) {
            if (newValue) {
                obj.light.mask |= pc.MASK_DYNAMIC;
            } else {
                obj.light.mask &= ~pc.MASK_DYNAMIC;
            }
            obj.light.setMask(obj.light.mask);
        });
        _defineProperty(c, d, s, "affectLightmapped", false, function(obj, newValue, oldValue) {
            if (newValue) {
                obj.light.mask |= pc.MASK_BAKED;
                if (obj.bake) obj.light.mask &= ~pc.MASK_LIGHTMAP;
            } else {
                obj.light.mask &= ~pc.MASK_BAKED;
                if (obj.bake) obj.light.mask |= pc.MASK_LIGHTMAP;
            }
            obj.light.setMask(obj.light.mask);
        });
        _defineProperty(c, d, s, "bake", false, function(obj, newValue, oldValue) {
            if (newValue) {
                obj.light.mask |= pc.MASK_LIGHTMAP;
                if (obj.affectLightmapped) obj.light.mask &= ~pc.MASK_BAKED;
            } else {
                obj.light.mask &= ~pc.MASK_LIGHTMAP;
                if (obj.affectLightmapped) obj.light.mask |= pc.MASK_BAKED;
            }
            obj.light.setMask(obj.light.mask);
        });
    };
    _defineProps(LightComponent.prototype, LightComponentData.prototype, LightComponentSystem.prototype);


    Object.defineProperty(LightComponent.prototype, "enable", {
        get: function() {
            console.warn("WARNING: enable: Property is deprecated. Query enabled property instead.");
            return this.enabled;
        },
        set: function(value) {
            console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
            this.enabled = value;
        },
    });

    pc.extend(LightComponent.prototype, {
        refreshProperties: function() {
            _props.forEach(function (prop) {
                this[prop] = this[prop];
            });
            if (this.enabled && this.entity.enabled)
                this.onEnable();
        },

        updateShadow: function() {
            this.light.updateShadow();
        },

        onEnable: function () {
            LightComponent._super.onEnable.call(this);
            this.light.setEnabled(true);
        },

        onDisable: function () {
            LightComponent._super.onDisable.call(this);
            this.light.setEnabled(false);
        }
    });

    pc.extend(LightComponentSystem.prototype, {
        initializeComponentData: function (component, _data) {
            // duplicate because we're modifying the data
            var data = {};
            _props.forEach(function (prop) {
                data[prop] = _data[prop];
            });

            if (!data.type)
                data.type = component.data.type;

            component.data.type = data.type;

            if (data.color && pc.type(data.color) === 'array')
                data.color = new pc.Color(data.color[0], data.color[1], data.color[2]);

            if (data.enable) {
                console.warn("WARNING: enable: Property is deprecated. Set enabled property instead.");
                data.enabled = data.enable;
            }

            var light = new pc.Light();
            light.setType(lightTypes[data.type]);
            light._node = component.entity;
            this.app.scene.addLight(light);
            component.data.light = light;

            LightComponentSystem._super.initializeComponentData.call(this, component, data, _props);
        },

        onRemove: function (entity, data) {
            this.app.scene.removeLight(data.light);
        },

        cloneComponent: function (entity, clone) {
            var light = entity.light;

            var data = [];
            var name;
            for(var i=0; i<_props.length; i++) {
                name = _props[i];
                if (light[name] && light[name].clone) {
                    data[name] = light[name].clone();
                } else {
                    data[name] = light[name];
                }
            }
            data.light = null;

            this.addComponent(clone, data);
        },

        changeType: function (component, oldValue, newValue) {
            if (oldValue!==newValue) {
                component.light.setType(lightTypes[newValue]);
            }
        }
    });


    return {
        LightComponent: LightComponent,
        LightComponentData: LightComponentData,
        LightComponentSystem: LightComponentSystem
    };
}());
